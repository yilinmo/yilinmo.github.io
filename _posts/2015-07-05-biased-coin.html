---
layout: post
title: How to Get Fair Results from a Biased Coin
comments: true
---
<hr  />

<p>
<i>This is a test of org-babel.</i>
</p>

<p>
Consider we have a biased coin, such that the probability of getting a head is \(P(H) = p\in(0,1)\) and the probability of getting a tail is \(P(T) = q = 1-p\), where \(p\) is unknown by us. However, different coin tosses are independent from each other. 
</p>

<p>
Our goal is to generate a "fair" binary random variable \(X\), with distribution \(P(X = 0) = P(X=1) = 0.5\). One way to generate such a random variable is to:
</p>
<ol class="org-ol">
<li>Toss the coin twice. 
</li>
<li>If the result is <b>HT</b>, assign \(X = 0\). If the result is <b>TH</b>, assign \(X = 1\).
</li>
<li>If the result is either <b>HH</b> or <b>TT</b>, then discard the two coin tosses and go to step 1.
</li>
</ol>

<p>
The probability of making an <b>HH</b> or <b>TT</b> for two tosses is
</p>
\begin{align}
\label{eq:failprobability}
P(HH) + P(TT) = p^2 + q^2.
\end{align} 

<p>
Therefore, the probability of finally getting <b>HT</b> (and thus setting \(X = 0\)) is<sup><a id="fnr.1" name="fnr.1" class="footref" href="#fn.1">1</a></sup>
</p>
\begin{align}
&P(HT) + \left(P(HH) + P(TT) \right)P(HT)\nonumber \\
&+  \left(P(HH) + P(TT) \right)^2P(HT) +\dots\nonumber\\
& = \frac{pq}{1-p^2-q^2} = \frac{1}{2}.
\label{eq:zeroprobability}
\end{align}
<p>
Similar, the probability of \(X = 1\) is \(0.5\) and hence we get a fail result from a biased coin.
</p>

<p>
The expected number of coin tosses needed to generate \(X\) is
</p>

\begin{align}
\label{eq:expectnum}
\sum_{n=1}^\infty 2n(1-p^2-q^2)(p^2+q^2)^{n-1} = \frac{1}{pq}.
\end{align}

<p>
Below is a python script for the coin toss algorithm:
</p>

{% highlight python %}
import random

def flipcoin(p):
    if random.uniform(0,1) <= p:
	return 'H'
    else:
	return 'T'

def check(toss): #return s, where n = 2^s*(2t+1)
    if toss == 'HT':
	return 0
    elif toss == 'TH':
	return 1
    else:
	return None

X = None
p = 0.5
print("Coin Toss Sequence: ", end = "")
while X is None:
    toss = flipcoin(p) + flipcoin(p)
    print(toss, end = "")
    X = check(toss)

print("\nX = " + str(X))

{% endhighlight %}

<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">A More Efficient Algorithm</h2>
<div class="outline-text-2" id="text-1">
<p>
The above algorithm is not every efficient in the sense that it wastes some coin tosses. To see this, consider the sequence <b>HHTT</b> and <b>TTHH</b>. Notice that they both occur with probability \(p^2q^2\) and thus we can map <b>HHTT</b> to \(X = 0\) and <b>TTHH</b> to \(X = 1\). However, in the above algorithm, both of the sequences will be discarded.
</p>

<p>
To generalize this idea, we will define an \((n,m)\) sequence to be a coin toss sequence with \(n\) tosses and \(m\) heads. We know that all \((n,m)\) sequences will have the same probability \(p^m q^{n-m}\). Thus, if \(n\choose{m}\) is even, then we can map half of such sequences to \(0\) and the other half to \(1\). This will lead to a more efficient use of coin tosses.
</p>

<p>
However, some sequences may terminate early. For example, there are \(6\) possible \((4,2)\) sequences. However, the sequences <b>HTHT</b> is not possible since we will stop coin tossing when we see the first two coin tosses: <b>HT</b>. In fact, <b>HHTT</b> and <b>TTHH</b> are the only \(4\) toss sequences with \(2\) heads.
</p>

<p>
In order to take this early termination into account, let us define \(m(k)\) as the number of heads after \(k\)-th coin toss. Then the coin toss sequence of length \(n\) can be uniquely determined by \(m(1),\,m(2),\,\dots,\,m(n)\). Indeed, the \(k\)-th coin toss is <b>H</b> if \(m(k) - m(k-1) = 1\). It is <b>T</b> if \(m(k) -m(k-1) = 0\). <sup><a id="fnr.2" name="fnr.2" class="footref" href="#fn.2">2</a></sup>
</p>

<p>
We will call a \((n,m)\) sequence of to be valid if it does not terminate before the \(n\)-th toss<sup><a id="fnr.3" name="fnr.3" class="footref" href="#fn.3">3</a></sup>. In other words, for all \(k < n\), \(k\choose{m(k)}\) is odd. Let us define \(f(n,m)\) to be the number of valid \((n,m)\) sequences. 
</p>

<div class="theorem">
<p>
<b>Theorem 1</b>: \(f(n,m)\) is either \(0\), \(1\) or \(2\). Moreover, \(f(n,m)\) satisfies<sup><a id="fnr.4" name="fnr.4" class="footref" href="#fn.4">4</a></sup>:
</p>
<ol class="org-ol">
<li>If \(f(n-1,m-1) = 1\) and \(f(n-1,m) = 1\), then \(f(n,m) = 2\).
</li>
<li>If \(f(n-1,m-1) + f(n-1,m)\) is odd, then \(f(n,m) = 1\).
</li>
<li>Otherwise \(f(n,m) = 0\).
</li>
</ol>

</div>

<p>
The proof follows from the following facts:
</p>
<ul class="org-ul">
<li>If a \((n,m)\) sequence is valid, then the first \(n-1\) tosses must be either a valid \((n-1,m-1)\) or a valid \((n-1,m)\) sequence.
</li>
<li>We will terminate our toss whenever \(f(n,m)\) is even.
</li>
</ul>

<p>
We can us the following code to generate a table of \(f(n,m)\). 
</p>
{% highlight python %}
def table(N):
    fold = [1,] #f(0,0) = 1
    print('1')
    for n in range(1, N+1):
	fnew = [1,] #f(n,0) is always 1
	print('1', end=' ')
	for m in range(1, n):
	    if fold[m-1] == 1 and fold[m] == 1:
		f = 2
	    elif (fold[m-1]+fold[m])%2 == 1:
		f = 1
	    else:
		f = 0
	    fnew.append(f)
	    print(str(f), end=' ')
	fnew.append(1) #f(n,n) is always 1
	print('1')
	fold = fnew

table(10)

{% endhighlight %}

<pre class="example">
1
1 1
1 2 1
1 1 1 1
1 2 2 2 1
1 1 0 0 1 1
1 2 1 0 1 2 1
1 1 1 1 1 1 1 1
1 2 2 2 2 2 2 2 1
1 1 0 0 0 0 0 0 1 1
1 2 1 0 0 0 0 0 1 2 1
</pre>

<p>
By Theorem 1, we know that if \(f(n,m) = 2\), then the last toss of the one valid \((n,m)\) sequence is <b>H</b> and the last toss of the other is <b>T</b>. Hence, our more efficient algorithm can be described as follows:
</p>
<ol class="org-ol">
<li>If \(k\choose{m(k)}\) is even, then assign \(X = 0\) if the last toss is <b>T</b>. Assign \(X = 1\) if the last toss is <b>H</b>.
</li>
<li>If \(k\choose{m(k)}\) is odd, then toss another coin and update \(k\) and $m
</li>
</ol>
</div>
</div>
<div id="footnotes">
<h2 class="footnotes">Footnotes: </h2>
<div id="text-footnotes">

<div class="footdef"><sup><a id="fn.1" name="fn.1" class="footnum" href="#fnr.1">1</a></sup> <p>
Notice that \(p^2+q^2 = 1-2pq\).
</p></div>

<div class="footdef"><sup><a id="fn.2" name="fn.2" class="footnum" href="#fnr.2">2</a></sup> <p>
We will define \(m(0) = 0\).
</p></div>

<div class="footdef"><sup><a id="fn.3" name="fn.3" class="footnum" href="#fnr.3">3</a></sup> <p>
However, it can terminate at the \(n\)-th toss.
</p></div>

<div class="footdef"><sup><a id="fn.4" name="fn.4" class="footnum" href="#fnr.4">4</a></sup> <p>
We assume \(f(n,-1) = 0\) and \(f(n,n+1) = 0\).
</p></div>


</div>
</div>
